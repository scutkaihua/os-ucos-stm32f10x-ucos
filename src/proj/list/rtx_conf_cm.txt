; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\rtx_conf_cm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\rtx_conf_cm.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\app -I..\outlib -I..\app\inc -ID:\Keil\ARM\RV31\INC -ID:\Keil\ARM\CMSIS\Include -ID:\Keil\ARM\Inc\ST\STM32F10x -DSTM32F10X_HD --omf_browse=.\obj\rtx_conf_cm.crf ..\config\RTX_Conf_CM.c]
                          THUMB

                          AREA ||i.__user_perthread_libspace||, CODE, READONLY, ALIGN=2

                  __user_perthread_libspace PROC
;;;376    
;;;377    void *__user_perthread_libspace (void) {
000000  b510              PUSH     {r4,lr}
;;;378      /* Provide a separate libspace for each task. */
;;;379      U32 idx;
;;;380    
;;;381      idx = runtask_id ();
000002  f7fffffe          BL       rt_tsk_self
;;;382      if (idx == 0) {
000006  b130              CBZ      r0,|L1.22|
;;;383        /* RTX not running yet. */
;;;384        return (&__libspace_start);
;;;385      }
;;;386      return ((void *)&std_libspace[idx-1]);
000008  4904              LDR      r1,|L1.28|
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  eb011040          ADD      r0,r1,r0,LSL #5
000012  3860              SUBS     r0,r0,#0x60
;;;387    }
000014  bd10              POP      {r4,pc}
                  |L1.22|
000016  4802              LDR      r0,|L1.32|
000018  bd10              POP      {r4,pc}
;;;388    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      ||.bss||+0x5b8
                  |L1.32|
                          DCD      __libspace_start

                          AREA ||i._mutex_acquire||, CODE, READONLY, ALIGN=2

                  _mutex_acquire PROC
                  ||__tagsym$$used||
;;;405    
;;;406    __used void _mutex_acquire (OS_ID *mutex) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;407      /* Acquire a system mutex, lock stdlib resources. */
;;;408      if (runtask_id ()) {
000004  f7fffffe          BL       rt_tsk_self
000008  2800              CMP      r0,#0
00000a  d005              BEQ      |L2.24|
;;;409        /* RTX running, acquire a mutex. */
;;;410        mutex_wait (*mutex);
00000c  f64f71ff          MOV      r1,#0xffff
000010  f8dfc008          LDR      r12,|L2.28|
000014  6820              LDR      r0,[r4,#0]
000016  df00              SVC      #0x0
                  |L2.24|
;;;411      }
;;;412    }
000018  bd10              POP      {r4,pc}
;;;413    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      rt_mut_wait

                          AREA ||i._mutex_initialize||, CODE, READONLY, ALIGN=2

                  _mutex_initialize PROC
;;;390    
;;;391    int _mutex_initialize (OS_ID *mutex) {
000000  4a08              LDR      r2,|L3.36|
000002  b510              PUSH     {r4,lr}
;;;392      /* Allocate and initialize a system mutex. */
;;;393    
;;;394      if (nr_mutex >= OS_MUTEXCNT) {
000004  6851              LDR      r1,[r2,#4]  ; nr_mutex
000006  4603              MOV      r3,r0                 ;391
000008  2908              CMP      r1,#8
00000a  d300              BCC      |L3.14|
                  |L3.12|
;;;395        /* If you are here, you need to increase the number OS_MUTEXCNT. */
;;;396        for (;;);
00000c  e7fe              B        |L3.12|
                  |L3.14|
;;;397      }
;;;398      *mutex = &std_libmutex[nr_mutex++];
00000e  4806              LDR      r0,|L3.40|
000010  eb001001          ADD      r0,r0,r1,LSL #4
000014  1c49              ADDS     r1,r1,#1
000016  6018              STR      r0,[r3,#0]
;;;399      mutex_init (*mutex);
000018  6051              STR      r1,[r2,#4]  ; nr_mutex
00001a  f7fffffe          BL       rt_mut_init
;;;400      return (1);
00001e  2001              MOVS     r0,#1
;;;401    }
000020  bd10              POP      {r4,pc}
;;;402    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      ||.data||
                  |L3.40|
                          DCD      ||.bss||+0xb58

                          AREA ||i._mutex_release||, CODE, READONLY, ALIGN=2

                  _mutex_release PROC
                  |symbol_number.84|
;;;416    
;;;417    __used void _mutex_release (OS_ID *mutex) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;418      /* Release a system mutex, unlock stdlib resources. */
;;;419      if (runtask_id ()) {
000004  f7fffffe          BL       rt_tsk_self
000008  2800              CMP      r0,#0
00000a  d003              BEQ      |L4.20|
;;;420        /* RTX runnning, release a mutex. */
;;;421        mutex_rel (*mutex);
00000c  f8dfc008          LDR      r12,|L4.24|
000010  6820              LDR      r0,[r4,#0]
000012  df00              SVC      #0x0
                  |L4.20|
;;;422      }
;;;423    }
000014  bd10              POP      {r4,pc}
;;;424    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      rt_mut_release

                          AREA ||i.os_error||, CODE, READONLY, ALIGN=1

                  os_error PROC
;;;194    
;;;195    void os_error (U32 err_code) {
000000  bf00              NOP      
;;;196      /* This function is called when a runtime error is detected. Parameter */
;;;197      /* 'err_code' holds the runtime error code (defined in RTL.H).         */
;;;198      err_code = err_code;
;;;199      /* HERE: include optional code to be executed on runtime error. */
;;;200      //for (;;);
;;;201    }
000002  4770              BX       lr
;;;202    
                          ENDP


                          AREA ||i.os_idle_demon||, CODE, READONLY, ALIGN=1

                  os_idle_demon PROC
;;;154    
;;;155    __task void os_idle_demon (void) {
000000  bf00              NOP      
                  |L6.2|
;;;156      /* The idle demon is a system task, running when no other task is ready */
;;;157      /* to run. The 'os_xxx' function calls are not allowed from this task.  */
;;;158    
;;;159      for (;;) {
000002  e7fe              B        |L6.2|
;;;160      /* HERE: include optional user code to be executed when no task runs.*/
;;;161      }
;;;162    }
;;;163    
                          ENDP


                          AREA ||i.os_tmr_call||, CODE, READONLY, ALIGN=1

                  os_tmr_call PROC
;;;184    
;;;185    void os_tmr_call (U16 info) {
000000  4770              BX       lr
;;;186      /* This function is called when the user timer has expired. Parameter   */
;;;187      /* 'info' holds the value, defined when the timer was created.          */
;;;188    
;;;189      /* HERE: include optional user code to be executed on timeout. */
;;;190    }
;;;191    
                          ENDP


                          AREA ||i.rt_chk_robin||, CODE, READONLY, ALIGN=1

                  rt_chk_robin PROC
;;;360     void rt_init_robin (void) {;}
;;;361     void rt_chk_robin  (void) {;}
000000  4770              BX       lr
;;;362    #endif
                          ENDP


                          AREA ||i.rt_init_robin||, CODE, READONLY, ALIGN=1

                  rt_init_robin PROC
;;;359    #if (__CM__) && OS_ROBIN == 0
;;;360     void rt_init_robin (void) {;}
000000  4770              BX       lr
;;;361     void rt_chk_robin  (void) {;}
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=3

                  mp_tcb
                          %        856
                  mp_stk
                          %        416
                  os_fifo
                          %        132
                  os_active_TCB
                          %        60
                  std_libspace
                          %        1440
                  std_libmutex
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  os_tick
                          DCD      0x000007d0
                  os_maxtaskrun
000004  000f              DCW      0x000f
000006  0000              DCB      0x00,0x00
                  os_stackinfo
                          DCD      0x010e00c4
                  os_rrobin
                          DCD      0x00000005
                  os_trv
                          DCD      0x0001193f
                  os_flags
000014  01000000          DCB      0x01,0x00,0x00,0x00
                  os_clockrate
                  |symbol_number.30|
                          DCD      0x000007d0
                  os_timernum
                  |symbol_number.31|
                          DCD      0x00000000
                  mp_tcb_size
000020  0354              DCW      0x0354
000022  0000              DCB      0x00,0x00
                  mp_stk_size
                          DCD      0x000001a0
                  os_fifo_size
000028  1000              DCB      0x10,0x00
                  mp_tmr_size
00002a  0000              DCW      0x0000

                          AREA ||.data||, DATA, ALIGN=2

                  m_tmr
                          DCD      0x00000000
                  nr_mutex
                          DCD      0x00000000
